import 'dart:convert' as dart_convert;
import 'dart:io' as dart_io;
import 'dart:math' as dart_math;

import 'package:analyzer/dart/ast/ast.dart' as analyzer_ast;
import 'package:obfuscator/src/collector.dart';
import 'package:obfuscator/src/config.dart';
import 'package:obfuscator/src/mappings.dart';

/// Object utilised for generating resources required for obfuscation operations.
///
class Generator {
  /// Generates an instance of the [collector] data generator with provided [configuration].
  ///
  Generator({
    required Configuration configuration,
    required ObjectCollector collector,
  }) : _configuration = configuration,
       _collector = collector;

  /// Object defining the basic input options for the obfuscation service.
  ///
  final Configuration _configuration;

  /// Property holding the value of the main object collector.
  ///
  final ObjectCollector _collector;

  /// Collection of names generated by the service.
  ///
  /// This value is referenced in order to avoid duplicate name entries.
  ///
  final _generatedNames = <String>{};

  /// Contextual and built-in language keywords.
  ///
  /// This value is referenced in order to avoid disallowed name entries.
  ///
  final _reservedKeywords = const {
    'abstract',
    'as',
    'assert',
    'async',
    'await',
    'break',
    'case',
    'catch',
    'class',
    'const',
    'continue',
    'covariant',
    'default',
    'deferred',
    'do',
    'dynamic',
    'else',
    'enum',
    'export',
    'extends',
    'extension',
    'external',
    'factory',
    'false',
    'final',
    'finally',
    'for',
    'Function',
    'get',
    'hide',
    'if',
    'implements',
    'import',
    'in',
    'interface',
    'is',
    'late',
    'library',
    'mixin',
    'new',
    'null',
    'on',
    'operator',
    'part',
    'required',
    'rethrow',
    'return',
    'set',
    'show',
    'static',
    'super',
    'switch',
    'sync',
    'this',
    'throw',
    'true',
    'try',
    'typedef',
    'var',
    'void',
    'while',
    'with',
    'yield',
  };

  /// Random value generator.
  ///
  final _random = dart_math.Random();

  /// Generates a random string of the specified [length].
  ///
  /// The first letter of the string can be uppercased by specifying [firstLetterUppercase] as `true`.
  ///
  String _generateRandomString({
    required bool firstLetterUppercase,
    int length = 10,
    required bool privateIdentifier,
  }) {
    if (privateIdentifier) length--;
    const letters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const numbers = '0123456789';
    const characters = letters + numbers;
    late String value;
    do {
      value = String.fromCharCodes(
        Iterable.generate(
          length,
          (index) {
            final replacementSelection = index == 0 ? letters : characters;
            final replacementIndex = _random.nextInt(replacementSelection.length);
            return replacementSelection.codeUnitAt(replacementIndex);
          },
        ),
      );
      if (firstLetterUppercase) {
        value = value[0].toUpperCase() + value.substring(1);
      } else {
        value = value[0].toLowerCase() + value.substring(1);
      }
    } while (_reservedKeywords.contains(value.toLowerCase()) || _generatedNames.contains(value));
    _generatedNames.add(value);
    return privateIdentifier ? '_$value' : value;
  }

  /// Generates a name with first letter being uppercase.
  ///
  String _generateUppercaseName({
    required int length,
    required bool privateIdentifier,
  }) {
    return _generateRandomString(
      length: length,
      firstLetterUppercase: true,
      privateIdentifier: privateIdentifier,
    );
  }

  /// Generates a name with first letter being lowercase.
  ///
  String _generateLowercaseName({
    required int length,
    required bool privateIdentifier,
  }) {
    return _generateRandomString(
      length: length,
      firstLetterUppercase: false,
      privateIdentifier: privateIdentifier,
    );
  }

  /// Generates a unique identifier from the [originalId] value.
  ///
  String _generateUniqueIdentifier({
    required String originalId,
    required Type type,
  }) {
    final privateIdentifier = originalId.startsWith('_') == true;
    return switch (type) {
      const (analyzer_ast.ClassDeclaration) ||
      const (analyzer_ast.EnumDeclaration) ||
      const (analyzer_ast.MixinDeclaration) ||
      const (analyzer_ast.ExtensionDeclaration) ||
      const (analyzer_ast.TypeParameter) => _generateUppercaseName(
        privateIdentifier: privateIdentifier,
        length: originalId.length,
      ),
      const (analyzer_ast.ConstructorDeclaration) ||
      const (analyzer_ast.FunctionDeclaration) ||
      const (analyzer_ast.MethodDeclaration) ||
      const (analyzer_ast.EnumConstantDeclaration) ||
      const (analyzer_ast.TopLevelVariableDeclaration) ||
      const (analyzer_ast.VariableDeclaration) ||
      const (analyzer_ast.FieldDeclaration) ||
      const (analyzer_ast.FieldFormalParameter) ||
      const (analyzer_ast.SuperFormalParameter) ||
      const (analyzer_ast.SimpleFormalParameter) => _generateLowercaseName(
        privateIdentifier: privateIdentifier,
        length: originalId.length,
      ),
      Type() => throw UnimplementedError(
        'Declaration mapping setup not implemented for $originalId of $type.',
      ),
    };
  }

  /// Collection of unobfuscated names and their respective replacement mappings.
  ///
  final _mappings = <Mapping>[];

  /// Replaces the copied file contents with new top-level object identifiers.
  ///
  Future<void> processCopiedSourceDirectories() async {
    // Define iterations count, used for debugging and user review.
    int currentIterations = 0;
    int totalIterations = 0;
    for (final declaration in _collector.objectDeclarationCollector.collection) {
      totalIterations += declaration.references.length;
    }
    // Process merged file contents and generate obfuscated contents.
    for (final declaration in _collector.objectDeclarationCollector.collection) {
      if (declaration.lexeme?.isNotEmpty == true) {
        final replacementId = _generateUniqueIdentifier(
          originalId: declaration.lexeme!,
          type: declaration.type,
        );
        for (final reference in declaration.references) {
          final declaringFile = dart_io.File(reference.filePath);
          String declaringFileContents = await declaringFile.readAsString();
          declaringFileContents =
              declaringFileContents.substring(0, reference.offset) +
              replacementId +
              declaringFileContents.substring(
                reference.offset + replacementId.length,
              );
          currentIterations++;
          await declaringFile.writeAsString(
            declaringFileContents,
          );
          print(
            'Wrote $currentIterations/$totalIterations file ${declaringFile.path} iterations. '
            'Latest: ${declaration.lexeme}.',
          );
        }
        _mappings.add(
          Mapping(
            filePath: declaration.filePath,
            id: declaration.lexeme,
            replacementId: replacementId,
            parentId: declaration.parentId,
            offset: declaration.offset,
            referenceMappings: [
              for (final reference in declaration.references)
                Mapping(
                  filePath: reference.filePath,
                  id: reference.lexeme,
                  replacementId: replacementId,
                  parentId: reference.parentId,
                  offset: reference.offset,
                  referenceMappings: null,
                ),
            ],
          ),
        );
      }
    }
    // Record source code mappings.
    final mappingsFileContents = _mappings.map(
      (mapping) {
        return mapping.toJson();
      },
    ).toList();
    await _configuration.outputMappingsFile.writeAsString(
      dart_convert.jsonEncode(
        mappingsFileContents,
      ),
    );
  }
}
